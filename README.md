<h1>HyperLogLog</h1>
<p>
  Алгоритм для подсчета количества уникальных элементов в последовательности
</p>

<h4>
  Описание алгоритма
</h4>
<p>Подробно расписано <a href="https://m.habr.com/ru/post/119852/">здесь</a>, а супер подробно <a href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf">здесь</a></p>
<p>Ну, а если вкратце, то алгоритм дает лишь оценку количества уникальных элементов с определенной погрешностью (ошибкой).</p>
<ul>
  <li>Получаем хеш каждой строки в файле (в целом неважно, что это - IPv4 или что-нибудь еще)</li>
  <li>Для каждой строки возможно вычислить "ранг" (r) - индекс первого ненулевого бита в хеше справа</li>
  <li>Если верить математической статистике и описанию алгоритма, то с некой долей вероятности можно предположить, то 2^R, где R-наибольший ранг – есть число уникальных элементов</li>
  <li>Однако, HyperLogLog улучшает оценку за счет некой формулы для параметра оценки E</li>
  <li>Величина E рассчитывает на основе "карты" M[m], где m - число элементов карты (кратное степени 2). Число m рассчитывает на основе допустимой ошибки, например, если брать 6,5%, то количество 256 элементов, если меньше,то больше</li>
  <li>От количества элементов карты напрямую зависит точность. Чем больше элементов, тем точнее</li>
</ul>
<h4>
Почему HyperLogLog?
</h4>
<p>
Алгоритм позволяет выделить постоянную память под расчет количества уникальных последовательностей. Ее объем зависит от количества m.
</p>
<p>
Если использовать "классический" подход с HashSet, например, то не смотря на то, что сложность всех операций будет O(1), "перегрев" памяти будет обеспечен.
</p>
<p>
Особенно, если ее немного, а массив данных очень большой, да и уникальности в нем мало.
</p>
<h4>Результаты тестирования</h4>
<table>
  <tr>
    <th>No</th>
    <th>Размер файла</th>
    <th>Число IPv4 адресов</th>
    <th>Число уникальных элементов (HyperLogLog)</th>
    <th>Число уникальных элементов (HashSet, работал вместе с HyperLogLog)</th>
    <th>Время, мс</th>
    <th>Ошибка, %</th>
  </tr>
  <tr>
    <td>0</td>
    <td>88 Кб</td>
    <td>10000</td>
    <td>625</td>
    <td>625</td>
    <td>29</td>
    <td>0.2%</td>
  </tr>
  <tr>
    <td>1</td>
    <td>88 Кб</td>
    <td>10000</td>
    <td>627</td>
    <td>625</td>
    <td>77</td>
    <td>3.5%</td>
  </tr>
  <tr>
    <td>2</td>
    <td>12 Мб</td>
    <td>1000000</td>
    <td>907519</td>
    <td>962170</td>
    <td>5440</td>
    <td>6.5%</td>
  </tr>
  <tr>
    <td>3</td>
    <td>12 Мб</td>
    <td>1000000</td>
    <td>961163</td>
    <td>962170</td>
    <td>2665</td>
    <td>0.2%</td>
  </tr>
  <tr>
    <td>4</td>
    <td>108 Мб</td>
    <td>10000000</td>
    <td>359934</td>
    <td>390625</td>
    <td>15808</td>
    <td>6.5%</td>
  </tr>
  <tr>
    <td>5</td>
    <td>108 Мб</td>
    <td>10000000</td>
    <td>390589</td>
    <td>390625</td>
    <td>11220</td>
    <td>0.2%</td>
  </tr>
  <tr>
    <td>6</td>
    <td>112 Гб</td>
    <td>7999999999</td>
    <td>1121131632</td>
    <td>not enough RAM</td>
    <td>2546398</td>
    <td>0,2%</td>
  </tr>
  <tr>
    <td>7</td>
    <td>112 Гб</td>
    <td>7999999999</td>
    <td>1071591140</td>
    <td>not enough RAM</td>
    <td>1883430</td>
    <td>3,5%</td>
  </tr>
  <tr>
    <td>8</td>
    <td>112 Гб</td>
    <td>7999999999</td>
    <td>1061092351</td>
    <td>not enough RAM</td>
    <td>1721308</td>
    <td>6,5%</td>
  </tr>
</table>
